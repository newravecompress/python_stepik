'''
Реализуйте программу, которая будет эмулировать работу с пространствами имен.
Необходимо реализовать поддержку создания пространств имен и добавление в них переменных.

В данной задаче у каждого пространства имен есть уникальный текстовый идентификатор – его имя.

Вашей программе на вход подаются следующие запросы:

create <namespace> <parent> –  создать новое пространство имен с именем <namespace> внутри пространства <parent>
add <namespace> <var> – добавить в пространство <namespace> переменную <var>
get <namespace> <var> – получить имя пространства, из которого будет взята переменная <var>
при запросе из пространства <namespace>, или None, если такого пространства не существует
Рассмотрим набор запросов

add global a
create foo global
add foo b
create bar foo
add bar a
Структура пространств имен описанная данными запросами будет эквивалентна структуре пространств имен,
созданной при выполнении данного кода

a = 0
def foo():
  b = 1
  def bar():
    a = 2
В основном теле программы мы объявляем переменную a, тем самым добавляя ее в пространство global.
Далее мы объявляем функцию foo, что влечет за собой создание локального для нее пространства имен внутри пространства global.
В нашем случае, это описывается командой create foo global.
Далее мы объявляем внутри функции foo функцию bar,
тем самым создавая пространство bar внутри пространства foo, и добавляем в bar переменную a.

Добавим запросы get к нашим запросам

get foo a
get foo c
get bar a
get bar b
Представим как это могло бы выглядеть в коде

a = 0
def foo():
  b = 1
  get(a)
  get(c)
  def bar():
    a = 2
    get(a)
    get(b)

Результатом запроса get будет имя пространства, из которого будет взята нужная переменная.
Например, результатом запроса get foo a будет global, потому что в пространстве foo не объявлена переменная a,
но в пространстве global, внутри которого находится пространство foo, она объявлена.
Аналогично, результатом запроса get bar b будет являться foo, а результатом работы get bar a будет являться bar.

Результатом get foo c будет являться None, потому что ни в пространстве foo,
ни в его внешнем пространстве global не была объявлена переменная с.

Более формально, результатом работы get <namespace> <var> является

<namespace>, если в пространстве <namespace> была объявлена переменная <var>
get <parent> <var> – результат запроса к пространству, внутри которого было создано пространство <namespace>,
если переменная не была объявлена
None, если не существует <parent>, т. е. <namespace>﻿ – это global
Формат входных данных

В первой строке дано число n (1 ≤ n ≤ 100) – число запросов.
В каждой из следующих n строк дано по одному запросу.
Запросы выполняются в порядке, в котором они даны во входных данных.
Имена пространства имен и имена переменных представляют из себя строки длины не более 10,
состоящие из строчных латинских букв.

Формат выходных данных

Для каждого запроса get выведите в отдельной строке его результат.
'''


# подготовим псевдо-дерево с переменными и скоупами
# скоупы будут лежать на одном уровне, у каждого из них будет список с переменными
# и у каждого, кроме global, будет еще имя скоупа-родителя
tree = {
    'global': {
        'vars': []
    }
    # 'first_scope': {
    #     'parent': 'global',
    #     'vars': [a, b]
    # }
    # 'second_scope': {
    #     'parent': 'first_scope',
    #     'vars': [a, b, c]
    # }
}


# чтобы проходить по нашему псевдо-дереву, необходимо сделать рекурсивную функцию
# она будет проходить по дереву, пока не дойдет до скоупа global
def get_value(namespace, variable):
    if namespace == 'global':
        if variable in tree[namespace]['vars']:
            print(namespace)
        else:
            print('None')
    else:
        if variable in tree[namespace]['vars']:
            print(namespace)
        else:
            get_value(tree[namespace]['parent'], variable)


for i in range(int(input())):
    operation, namespace, variable = input().split()
    if operation == 'add':
        tree[namespace]['vars'].append(variable)
    elif operation == 'create':
        tree[namespace] = {
            'parent': variable,
            'vars': []
        }
    elif operation == 'get':
        # если нужно получить значение скоупа, то придется пройтись рекурсивно по всему дереву
        # поэтому используем заранее подготовленную функцию
        get_value(namespace, variable)


'''
Пример решения. Будем храним две структуры:
1) Кто чей родитель
2) Переменные объявленные в данном пространстве имён

Если команда create -- создаём новое пространство имён 
(запоминаем родителя и создаём пустое множество переменных, объявленных в этом пространстве имен).

Если команда add -- то просто помещаем имя переменной в соответствующее множество.

Если команда get -- то проверяем наличие данной переменной в нашем пространстве имён, 
если не нашли: проверяем в родителе. Если не нашли в родителе, проверяем в родителе родителя и так далее. 
Как только нашли имя переменной -- вывели на экран пространство имён, в котором нашли. 
Если в процессе поиска мы имя не нашли (fst is None) -- выводим None на экран.
'''
n = int(input())

parent = {"global": None}
vs = {"global": set()}

for _ in range(n):
    t, fst, snd = input().split()
    if t == "create":
        parent[fst] = snd
        vs[fst] = set()
    elif t == "add":
        vs[fst].add(snd)
    else:  # t == get
        while fst is not None:
            if snd in vs[fst]:
                break
            fst = parent[fst]
        print(fst)
