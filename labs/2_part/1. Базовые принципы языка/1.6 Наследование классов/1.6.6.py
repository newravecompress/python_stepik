"""
Какие последовательности могут являться корректным порядком разрешения методов для класса E?
"""

class A:
    pass

class B(A):
    pass

class C:
    pass

class D(C):
    pass

class E(B, C, D):
    pass


print(E.mro())



'''
Для запоминания порядка MRO:

1) если среди родителей класса - два класса, которые являются прямыми "родственниками", 
причём "родитель" перечислен до "потомка" - то возникает ошибка.  
Потому, как - вроде программист определяет такой  порядок, а MRO предусматривает обратный 
(т.е. сначала "потомки" - потом "родители").

P.S. (1) Конечно, разработчикам можно было и избегать ошибки, самостоятельно определяя что приоритетнее - 
но это противоречит "Дзену Python'а" (явное лучше подразумеваемого) - а потому, 
python заставляет программиста точно определиться - либо поменять порядок, 
либо выкинуть один из классов из списка родителей..

2) если же предыдущее правило не нарушается, то MRO строится "слева --> направо" до ближайшего "общего родителя". 
Все "родители" должны расположится после своих "прямых" и "опосредованных" потомков, но как можно левее (раньше).
 
P.S. (2) Получается что-то похожее на рекурсию или алгоритм класса "разделяй и властвуй", 
когда модель графа наследования делятся на кусочки до "ближайшего общего родителя", 
выполняется построение до этого "общего родителя", а потом этот "родитель" рассматривается как 
отдельный узел графа для выстраивания последующего порядка разрешения методов..
'''
